<?php

/**
 * Scaffold will generate a base and a child class that extends from the base.
 * The base class will be overwritten every single time. Do NOT add any code to the base as it will be overwritten.
 * The child class acts as a shell and should be used to extend and add functionality to the base case
 *
 * The following files types are generated by Scaffold:
 *
 * Table
 * Rowset
 * Row
 * Form
 * Constants
 *
 * http://zendframework.com/manual/en/zend.codegenerator.html
 *
 */
class DDM_Scaffold_Rowsets extends DDM_Scaffold_Abstract {

/*===============================
** Properties
**===============================*/

    /**
     * Array that holds a list of parent classes to use for tables, rowsets, rows, and forms
     *
     * @var array
     */
    protected $parentClass = array();

    /**
     * Array that holds a list of base classes to use for tables, rowsets, rows, and forms
     *
     * @var array
     */
    protected $baseClass = array();

/*=================================
** Constructor and Related Methods
**=================================*/

    /**
     * Allows setting up of parent classes that should be used
     *
     * @param array $config
     *
     * @return void
     */
    protected function initGeneral($config) {
        if (!array_key_exists('parentClass', $config)) {
            $config['parentClass'] = array();
        }

        if (!array_key_exists('table', $config['parentClass'])) {
            $config['parentClass']['table'] = 'Zend_Db_Table_Abstract';
        }

        if (!array_key_exists('rowset', $config['parentClass'])) {
            $config['parentClass']['rowset'] = 'Zend_Db_Table_Rowset_Abstract';
        }

        if (!array_key_exists('row', $config['parentClass'])) {
            $config['parentClass']['row'] = 'Zend_Db_Table_Row_Abstract';
        }

        if (!array_key_exists('form', $config['parentClass'])) {
            $config['parentClass']['form'] = 'ZendX_JQuery_Form';
        }

        $this->parentClass = $config['parentClass'];
    }

/*===============================
** Main Generator
**===============================*/

    /**
     * Generate acts as a helper method to call all other generate methods
     *
     * @return void
     */
    public function generate() {
        $this->output('===Master Generator Initiated===');
        $this->generateTables();
        $this->generateRowsets();
        $this->generateRows();
        $this->generateForms();
        $this->generateConstants();
        $this->generateSQLDumps();
        $this->generateTablesSQL();
        $this->generateTriggersSQL();
        $this->output('===Master Generator Complete===');
    }

/*===============================
** Table Generator
**===============================*/

    /**
     * Master function to create the table class for all tables in every databases requested
     *
     * @return void
     */
    public function generateTables() {
        $this->output('==Table Generator Initiated==');
        $this->generateBaseTable();

        $this->createDefaultPaths(array(
            'tables' => 'Tables/',
        ));
        $applicationBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['tables'];
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['tables'];

        $this->makeDirectory($applicationBasePath);
        $this->makeDirectory($generatedBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($applicationBasePath . $namespace);
            $this->makeDirectory($generatedBasePath . $namespace);

            $tables = $this->getTables($database);
            foreach ($tables as $table) {
                $results = $this->generateTable($table);
                if (!$results) {
                    $this->output('Table class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
                }
            }
        }
        $this->output('==Table Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the table classes
     *
     * @param array $table
     *
     * @return boolean
     */
    protected function generateTable($table) {
        $baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['tables'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        /* =================== */
        /* = Base Properties = */
        /* =================== */

        // Columns
        $columns = array();
        // We create a variable to pull defaults for a row class instead of information coming from the DB so we can customize the results using mysql column comments, etc
        $defaultValues = array();
        foreach ($table['COLUMNS'] as $column){
            $columns[] = $column['COLUMN_NAME'];
            $defaultValues[$column['COLUMN_NAME']] = $this->getDefaultColumnValue($column);
        }

        // Use the foreign key constraints to build up reference maps between the tables
        $referenceMap = array();
        foreach ($table['KEYS'] as $key) {
            $refTableFile = $this->paths['tables'] . $table['namespace'] . '/' . $this->makeClassName($key['REFERENCED_TABLE_NAME']);
            $refTableClass = $this->convertFileNameToClassName($refTableFile);
            $map = array(
                'columns' => $key['COLUMN_NAME'],
                'refTableClass' => $refTableClass,
                'refColumns' => $key['REFERENCED_COLUMN_NAME'],
            );
            $referenceMap[$key['CONSTRAINT_NAME']] = $map;
        }

        $baseProperties = array();
        $baseProperties[] = array(
            'name'         => '_metadata',
            'visibility'   => 'protected',
            'defaultValue' => $table['zend_describe_table'],
            'docblock' => 'Meta data cache to avoid describes at run time'
        );

        $baseProperties[] = array(
            'name'         => '_schema',
            'visibility'   => 'protected',
            'defaultValue' => $table['TABLE_SCHEMA'],
            'docblock' => 'DB name'
        );

        $baseProperties[] = array(
            'name'         => '_name',
            'visibility'   => 'protected',
            'defaultValue' => $table['TABLE_NAME'],
            'docblock' => 'Table name'
        );

        $baseProperties[] = array(
            'name'         => '_sequence',
            'visibility'   => 'protected',
            'defaultValue' => $table['AUTO_INCREMENT'],
            'docblock' => 'Does this table have an Auto Increment field?'
        );

        $baseProperties[] = array(
            'name'         => '_cols',
            'visibility'   => 'protected',
            'defaultValue' => $columns,
            'docblock' => 'Columns in the table'
        );

        $baseProperties[] = array(
            'name'         => '_primary',
            'visibility'   => 'protected',
            'defaultValue' => $table['PRIMARY_COLUMNS'],
            'docblock' => 'Fields that make up the Primary Key'
        );

        $baseProperties[] = array(
            'name' => '_referenceMap',
            'visibility' => 'protected',
            'defaultValue' => $referenceMap,
            'docblock' => 'Reference mapping from this table to other tables',
        );

        $baseProperties[] = array(
            'name' => '_defaultValues',
            'visibility' => 'protected',
            'defaultValue' => $defaultValues,
            'docblock' => 'Default values for a new row class',
        );

        $baseProperties[] = array(
            'name' => '_rowsetClass',
            'visibility' => 'protected',
            'defaultValue' => $this->getRowsetClass($table),
            'docblock' => 'Rowset class to use with table',
        );

        $baseProperties[] = array(
            'name' => '_rowClass',
            'visibility' => 'protected',
            'defaultValue' => $this->getRowClass($table),
            'docblock' => 'Row class to use with table',
        );

        /* ================ */
        /* = Base Methods = */
        /* ================ */

        $baseMethods = array();


        // Add convenience methods for getting rows by Indexed fields;
        // For example, User::getByUserID
        // This allows us to cache the results in the row objects
        foreach ($table['INDEXES'] as $indexes) {
            $variableName = $this->makeClassName($indexes['COLUMN_NAME']);
            $functionName = 'findBy' . ucfirst($variableName);

            $tableClassName = $this->getTableClassFromSchemaAndName($indexes['TABLE_SCHEMA'], $indexes['TABLE_NAME']);

            $baseMethods[] = array(
                'name' => $functionName,
                'visibility' => 'public',
                'parameters' => array(
                    array(
                        'name' => 'value'
                    ),
                    array(
                        'name' => 'select',
                        'defaultValue' => null,
                        'type' => 'Zend_Db_Select',
                    ),
                ),
                'body' => '
return $this->findByColumnValue(\''.$indexes['COLUMN_NAME'].'\', $value, $select);
                ',
                'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
                    'shortDescription' => 'Gets a Rowset from ' . $indexes['TABLE_NAME'] . ' by ' . $indexes['COLUMN_NAME'],
                    'tags' => array(
                        new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                            'paramName' => 'value',
                            'datatype' => 'string|number|null'
                        )),
                        new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                            'paramName' => 'select',
                            'datatype' => 'Zend_Db_Select|Zend_Db_Table_Select|null',
                            'description' => 'OPTIONAL'
                        )),
                        new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                            'datatype' => str_replace('Tables_', 'Rowsets_', $tableClassName),
                        )),
                    ),
                )),
            );
        }

        $baseDocBlock = $baseClassName . "\n\n";
        $baseDocBlock .= 'Generated class file for table '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
        $baseDocBlock .= 'Any changes here will be overridden.';

        $base = new Zend_CodeGenerator_Php_Class();
        $base->setName($baseClassName);
        $base->setDocblock($baseDocBlock);
        $base->setAbstract(true);
        $base->setProperties($baseProperties);
        $base->setMethods($baseMethods);
        $base->setExtendedClass($this->baseClass['table']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['tables'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        if (!file_exists($classFile)) {
            $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'Table for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
            $docBlock .= 'This class is a descendant of '.$this->parentClass['table'].' and can be used to add customizations to ' . $baseClassName;

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Creates the application specific table class. Aborts early if class already exists
     *
     * @return void
     */
    public function generateBaseTable() {
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
        $this->makeDirectory($generatedBasePath);

        $baseFile = $this->projectRoot . $generatedBasePath . 'Table.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $base = Zend_CodeGenerator_Php_Class::fromReflection(
            new Zend_Reflection_Class('DDM_Scaffold_Template_Base_Table')
        );
        $base->setSourceDirty(true);
        $base->setName($baseClassName);
        $base->setExtendedClass($this->parentClass['table']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $baseBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
        $this->makeDirectory($baseBasePath);

        $classFile = $this->projectRoot . $baseBasePath . 'Table.php';
        $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
        $this->baseClass['table'] = $className;
        if (!file_exists($classFile)) {
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'This class can be used to customize '.$this->parentClass['table'].' with application specific logic. ';
            $docBlock .= 'All other table classes extend from this class.';

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Returns the table filename for a given table
     *
     * @param array $table
     *
     * @return string $fileName
     */
    protected function getTableFile($table) {
        $this->createDefaultPaths(array(
            'tables' => 'Tables/',
        ));
        $fileName = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['tables'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        return $fileName;
    }

    /**
     * Returns the table class for a given table
     *
     * @param array $table
     *
     * @return string $className
     */
    protected function getTableClass($table) {
        $fileName = $this->getTableFile($table);
        $className = $this->convertFileNameToClassName($fileName, $this->paths['application'] . $this->paths['modules']);
        return $className;
    }

    /**
     * Returns the table class using a schema and table name
     *
     * @param string $schema
     * @param string $table
     *
     * @return string
     */
    protected function getTableClassFromSchemaAndName($schema, $table) {
        $table = array(
            'namespace' => $this->makeNamespace($schema),
            'classNamePartial' => $this->makeClassname($table),
        );
        return $this->getTableClass($table);
    }

/*===============================
** Rowset Generator
**===============================*/

    /**
     * Master function to create the rowset class for all tables in every databases requested
     *
     * @return void
     */
    public function generateRowsets() {
        $this->output('==Rowset Generator Initiated==');
        $this->generateBaseRowset();

        $this->createDefaultPaths(array(
            'rowsets' => 'Rowsets/',
        ));
        $applicationBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'];
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['rowsets'];

        $this->makeDirectory($applicationBasePath);
        $this->makeDirectory($generatedBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($applicationBasePath . $namespace);
            $this->makeDirectory($generatedBasePath . $namespace);

            $tables = $this->getTables($database);
            foreach ($tables as $table) {
                $results = $this->generateRowset($table);
                if (!$results) {
                    $this->output('Rowset class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
                }
            }
        }
        $this->output('==Rowset Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the rowset classes
     *
     * @param array $table
     *
     * @return boolean
     */
    protected function generateRowset($table) {
        $baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $baseProperties = array();

        $baseProperties[] = array(
            'name'         => '_tableClass',
            'visibility'   => 'protected',
            'defaultValue' => $this->getTableClass($table),
            'docblock' => 'Zend_Db_Table_Abstract class name',
        );

        $baseProperties[] = array(
            'name'         => '_rowClass',
            'visibility'   => 'protected',
            'defaultValue' => $this->getRowClass($table),
            'docblock' => 'Zend_Db_Row_Abstract class name',
        );

        $baseMethods = array();

        $baseDocBlock = $baseClassName . "\n\n";
        $baseDocBlock .= 'Generated class file for rowset '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
        $baseDocBlock .= 'Any changes here will be overridden.';

        $base = new Zend_CodeGenerator_Php_Class();
        $base->setName($baseClassName);
        $base->setDocblock($baseDocBlock);
        $base->setAbstract(true);
        $base->setProperties($baseProperties);
        $base->setMethods($baseMethods);
        $base->setExtendedClass($this->baseClass['rowset']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        if (!file_exists($classFile)) {
            $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'Rowset for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
            $docBlock .= 'This class is a descendant of '.$this->parentClass['rowset'].' and can be used to add customizations to ' . $baseClassName;

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Creates the application specific rowset class. Aborts early if class already exists
     *
     * @return void
     */
    public function generateBaseRowset() {
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
        $this->makeDirectory($generatedBasePath);

        $baseFile = $this->projectRoot . $generatedBasePath . 'Rowset.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $base = Zend_CodeGenerator_Php_Class::fromReflection(
            new Zend_Reflection_Class('DDM_Scaffold_Template_Base_Rowset')
        );
        $base->setSourceDirty(true);
        $base->setName($baseClassName);
        $base->setExtendedClass($this->parentClass['rowset']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $baseBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
        $this->makeDirectory($baseBasePath);

        $classFile = $this->projectRoot . $baseBasePath . 'Rowset.php';
        $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
        $this->baseClass['rowset'] = $className;
        if (!file_exists($classFile)) {
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'This class can be used to customize '.$this->parentClass['rowset'].' with application specific logic. ';
            $docBlock .= 'All other rowset classes extend from this class.';

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Returns the rowset filename for a given table
     *
     * @param array $table
     *
     * @return string $fileName
     */
    protected function getRowsetFile($table) {
        $this->createDefaultPaths(array(
            'rowsets' => 'Rowsets/',
        ));
        $fileName = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        return $fileName;
    }

    /**
     * Returns the rowset class for a given table
     *
     * @param array $table
     *
     * @return string $className
     */
    protected function getRowsetClass($table) {
        $fileName = $this->getRowsetFile($table);
        $className = $this->convertFileNameToClassName($fileName, $this->paths['application'] . $this->paths['modules']);
        return $className;
    }

/*===============================
** Row Generator
**===============================*/

    /**
     * Master function to create the row class for all tables in every databases requested
     *
     * @return void
     */
    public function generateRows() {
        $this->output('==Row Generator Initiated==');
        $this->generateBaseRow();

        $this->createDefaultPaths(array(
            'rows' => 'Rows/',
        ));
        $applicationBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'];
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['rows'];

        $this->makeDirectory($applicationBasePath);
        $this->makeDirectory($generatedBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($applicationBasePath . $namespace);
            $this->makeDirectory($generatedBasePath . $namespace);

            $tables = $this->getTables($database);
            foreach ($tables as $table) {
                $results = $this->generateRow($table);
                if (!$results) {
                    $this->output('Row class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
                }
            }
        }
        $this->output('==Row Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the row classes
     *
     * @param array $table
     *
     * @return boolean
     */
    protected function generateRow($table) {
        $baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $baseProperties = array();

        $baseProperties[] = array(
            'name'         => '_tableClass',
            'visibility'   => 'protected',
            'defaultValue' => $this->getTableClass($table),
            'docblock' => 'Zend_Db_Table_Abstract class name',
        );

        /* ================ */
        /* = Base Methods = */
        /* ================ */

        $baseMethods = array();

        // Create the getter/setters for each column
        foreach ($table['COLUMNS'] as $column) {
            $functionName = $this->makeClassName($column['COLUMN_NAME']);
            $columnType = $this->getColumnVarType($column);

            // Getter Variables
            $returnType = $columnType;
            $getParameters = array();
            $getDocblock = array(
                'shortDescription' => 'Returns the value for ' . $column['COLUMN_NAME'],
                'tags' => array(),
            );

            // Setter Variables
            $paramType = $columnType;
            $autocast = true;
            $setParameters = array(array(
                'name' => 'value'
            ));
            $setDocblock = array(
                'shortDescription' => 'Sets the value for ' . $column['COLUMN_NAME'],
                'tags' => array(),
            );

            $getBody = '$value = $this->getColumnValue(\''.$column['COLUMN_NAME'].'\');'."\n";
            $setBody = '';

            // If the column is time related, we need to store it in the correct format for saving to the database
            if ($this->isColumnTimeRelated($column)) {
                $dateFormat = $this->getDateFormatForColumn($column);

                $returnType .= '|int';
                // Give an option to return a timestamp if desired instead of the date string
                $getParameters[] = array(
                    'name' => 'returnUnixtime',
                    'defaultValue' => false,
                );
                $getDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                    'datatype' => 'boolean',
                    'paramName' => 'returnUnixtime',
                    'description' => 'OPTIONAL',
                    'position' => 1,
                ));
                $getBody .= 'if ('.(($column['IS_NULLABLE'] == 'YES') ? '$value !== null && ' : '').'$returnUnixtime) {
    $value = strtotime($value);
}
';

                // Give an option to not convert a string and reapply the date format. This allows people to pass in already
                // formated dates that occur before either 1901 or 1970 depending on the system
                $paramType .= '|int';
                $setParameters[] = array(
                    'name' => 'convertString',
                    'defaultValue' => true,
                );
                $setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                    'paramName' => 'convertString',
                    'datatype' => 'boolean',
                    'description' => 'OPTIONAL',
                ));

                if($column['IS_NULLABLE'] == 'YES'){
                    $setBody .= '
if(empty($value) && !is_numeric($value)) {
    $value = null;
}';
                }

                $setBody .= '
if ($value == \'CURRENT_TIMESTAMP\') {
    $value = date(\''.$dateFormat.'\');
} else if (is_numeric($value)) {
    $value = date(\''.$dateFormat.'\', $value);
} else if ('.(($column['IS_NULLABLE'] == 'YES') ? '$value !== null && ' : '').'$convertString) {
    $value = date(\''.$dateFormat.'\', strtotime($value));
}
';
            } else if ($this->columnHasComment('SERIALIZED_DATA', $column)) {
                // No special logic is needed for nulls here as serialize handles it correctly
                $autocast = false;
                $getBody .= '$value = unserialize($value);'."\n";
                $setBody .= '$value = serialize($value);'."\n";
            } else if ($this->columnHasComment('BOOLEAN', $column)) {
                $autocast = false;
                if ($column['IS_NULLABLE'] == 'YES') {
                    $getBody .= 'if ($value !== null) {'."\n";
                }
                $getBody .= '$value = (boolean) $value;'."\n";
                if ($column['IS_NULLABLE'] == 'YES') {
                    $getBody .= '}'."\n";
                }

                // If we cast to a boolean and then an int, PHP leans toward true too often.
                if ($column['IS_NULLABLE'] == 'YES') {
                    $setBody .= 'if ($value !== null) {'."\n";
                }
                $setBody .= '
if ($value === true || $value == 1 || $value === \'true\' || $value === \'TRUE\') {
    $value = 1;
} else {
    $value = 0;
}
';
                if ($column['IS_NULLABLE'] == 'YES') {
                    $setBody .= '}'."\n";
                }
            } else if ($this->columnHasComment('IP_ADDRESS', $column)) {
                $paramType = 'string';
                $returnType = 'string';
                $autocast = false;

                if ($column['IS_NULLABLE'] == 'YES') {
                    $getBody .= 'if ($value !== null) {'."\n";
                }
                    $getBody .= '$value = long2ip($value);'."\n";
                if ($column['IS_NULLABLE'] == 'YES') {
                    $getBody .= '}'."\n";
                }

                if ($column['IS_NULLABLE'] == 'YES') {
                    $setBody .= 'if ($value !== null) {'."\n";
                }
                    $setBody .= '$value = sprintf(\'%u\', ip2long($value));'."\n";
                if ($column['IS_NULLABLE'] == 'YES') {
                    $setBody .= '}'."\n";
                }
            }

            // Cast the value to the correct type
            if ($autocast) {
                if ($column['IS_NULLABLE'] == 'YES' || $this->isColumnAutoIncrement($column)) {
                    $setBody .= '
if ($value !== null) {
    $value = ('.$columnType.') $value;
}'."\n";
                } else {
                    $setBody .= '$value = ('.$columnType.') $value;'."\n";
                }
            }

            // Finish up the getter
            $getBody .= 'return $value;';
            $getDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                'datatype' => $returnType,
            ));
            $baseMethods[] = array(
                'name' => 'get' . $functionName,
                'visibility' => 'public',
                'parameters' => $getParameters,
                'body' => $getBody,
                'docblock' => $getDocblock,
            );


            // Finish up the setter
            $setBody .= '$this->setColumnValue(\''.$column['COLUMN_NAME'].'\', $value);';
            $setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                'paramName' => 'value',
                'datatype' => $paramType,
            ));
            $setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                'datatype' => 'void',
            ));
            $baseMethods[] = array(
                'name' => 'set' . $functionName,
                'visibility' => 'public',
                'parameters' => $setParameters,
                'body' => $setBody,
                'docblock' => $setDocblock,
            );
        }

        // Add convenience methods for getting related rows by foreign key constraints.
        // This allows us to cache the results in the row objects
        // @TODO: str_replace('Tables_', 'Rows_', $tableClassName) needs to be done right so if the classes have other names it still works. Applies to all key related functions
        foreach ($table['KEYS'] as $key) {
            $variableName = $key['REFERENCED_TABLE_NAME'] . '_row_by_' . $key['COLUMN_NAME'];
            $variableName = $this->makeClassName($variableName, false);
            $functionName = 'get' . ucfirst($variableName);
            $tableClassName = $this->getTableClassFromSchemaAndName($key['REFERENCED_TABLE_SCHEMA'], $key['REFERENCED_TABLE_NAME']);

            $baseProperties[] = array(
                'name'         => $variableName,
                'visibility'   => 'protected',
                'defaultValue' => array(),
                'type' => $tableClassName,
                'docblock' => 'Row object for ' . $key['REFERENCED_TABLE_NAME']
            );

            $baseMethods[] = array(
                'name' => $functionName,
                'visibility' => 'public',
                'parameters' => array(array(
                    'name' => 'select',
                    'defaultValue' => null,
                    'type' => 'Zend_Db_Select',
                )),
                'body' => '
$keyName = ($select !== null) ? sha1($select->__toString()) : \'noSelect\';
if (!array_key_exists($keyName, $this->'.$variableName.')) {
    $this->'.$variableName.'[$keyName] = $this->findParentRow(\''.$tableClassName.'\', \''.$key['CONSTRAINT_NAME'].'\', $select);
}
return $this->'.$variableName.'[$keyName];',
                'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
                    'shortDescription' => 'Gets the parent row from ' . $key['REFERENCED_TABLE_NAME'] . ' by ' . $key['COLUMN_NAME'],
                    'tags' => array(
                        new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                            'paramName' => 'select',
                            'datatype'  => 'Zend_Db_Select|null',
                        )),
                        new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                            'datatype'  => str_replace('Tables_', 'Rows_', $tableClassName),
                        )),
                    ),
                )),
            );
        }

        // Add convenience methods for getting related rowsets by foreign key constraints.
        // This allows us to cache the results in the rowset objects
        foreach ($table['DEPENDENT_KEYS'] as $key) {
            $variableName = $key['TABLE_NAME'] . '_rowset_by_' . $key['COLUMN_NAME'];
            $variableName = $this->makeClassName($variableName, false);
            $functionName = 'get' . ucfirst($variableName);
            $tableClassName = $this->getTableClassFromSchemaAndName($key['TABLE_SCHEMA'], $key['TABLE_NAME']);

            $baseProperties[] = array(
                'name'         => $variableName,
                'visibility'   => 'protected',
                'defaultValue' => array(),
                'type' => $tableClassName,
                'docblock' => 'Rowset object for ' . $key['TABLE_NAME']
            );

            $baseMethods[] = array(
                'name' => $functionName,
                'visibility' => 'public',
                'parameters' => array(array(
                    'name' => 'select',
                    'defaultValue' => null,
                    'type' => 'Zend_Db_Select',
                )),
                'body' => '
$keyName = ($select !== null) ? sha1($select->__toString()) : \'noSelect\';
if (!array_key_exists($keyName, $this->'.$variableName.')) {
    $this->'.$variableName.'[$keyName] = $this->findDependentRowset(\''.$tableClassName.'\', \''.$key['CONSTRAINT_NAME'].'\', $select);
}
return $this->'.$variableName.'[$keyName];',
                'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
                    'shortDescription' => 'Gets the dependent rowset from ' . $key['TABLE_NAME'] . ' by ' . $key['COLUMN_NAME'],
                    'tags' => array(
                        new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                            'paramName' => 'select',
                            'datatype'  => 'Zend_Db_Select|null',
                        )),
                        new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                            'datatype'  => str_replace('Tables_', 'Rowsets_', $tableClassName),
                        )),
                    ),
                )),
            );

            //Are there any many-to-many relationships we can create functions for?
            foreach ($key['RELATED_KEYS'] as $relatedKey) {
                $variableName = $relatedKey['REFERENCED_TABLE_NAME'] . '_rowset_via_' . $relatedKey['TABLE_NAME'] . '_by_' . $key['COLUMN_NAME'] . '_and_' . $relatedKey['COLUMN_NAME'];
                $variableName = $this->makeClassName($variableName, false);
                $functionName = 'get' . ucfirst($variableName);
                $destinationTableClassName = $this->getTableClassFromSchemaAndName($relatedKey['REFERENCED_TABLE_SCHEMA'], $relatedKey['REFERENCED_TABLE_NAME']);
                $intersectionTableClassName = $this->getTableClassFromSchemaAndName($relatedKey['TABLE_SCHEMA'], $relatedKey['TABLE_NAME']);

                $baseProperties[] = array(
                    'name'         => $variableName,
                    'visibility'   => 'protected',
                    'defaultValue' => array(),
                    'type' => $tableClassName,
                    'docblock' => 'Rowset object for ' . $relatedKey['REFERENCED_TABLE_NAME']
                );

                $baseMethods[] = array(
                    'name' => $functionName,
                    'visibility' => 'public',
                    'parameters' => array(array(
                        'name' => 'select',
                        'defaultValue' => null,
                        'type' => 'Zend_Db_Select',
                    )),
                    'body' => '
$keyName = ($select !== null) ? sha1($select->__toString()) : \'noSelect\';
if (!array_key_exists($keyName, $this->'.$variableName.')) {
    $this->'.$variableName.'[$keyName] = $this->findManyToManyRowset(\''.$destinationTableClassName.'\', \''.$intersectionTableClassName.'\', \''.$key['CONSTRAINT_NAME'].'\', \''.$relatedKey['CONSTRAINT_NAME'].'\', $select);
}
return $this->'.$variableName.'[$keyName];',
                    'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
                        'shortDescription' => 'Gets the many-to-many rowset from ' . $relatedKey['REFERENCED_TABLE_NAME'] . ' by ' . $key['COLUMN_NAME'] . ' and by ' . $relatedKey['COLUMN_NAME'],
                        'tags' => array(
                            new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                                'paramName' => 'select',
                                'datatype'  => 'Zend_Db_Select|null',
                            )),
                            new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                                'datatype'  => str_replace('Tables_', 'Rowsets_', $destinationTableClassName),
                            )),
                        ),
                    )),
                );
            }
        }

        $baseDocBlock = $baseClassName . "\n\n";
        $baseDocBlock .= 'Generated class file for row '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
        $baseDocBlock .= 'Any changes here will be overridden.';

        $base = new Zend_CodeGenerator_Php_Class();
        $base->setName($baseClassName);
        $base->setDocblock($baseDocBlock);
        $base->setAbstract(true);
        $base->setProperties($baseProperties);
        $base->setMethods($baseMethods);
        $base->setExtendedClass($this->baseClass['row']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        if (!file_exists($classFile)) {
            $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'Row for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
            $docBlock .= 'This class is a descendant of '.$this->parentClass['row'].' and can be used to add customizations to ' . $baseClassName;

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Creates the application specific row class. Aborts early if class already exists
     *
     * @return void
     */
    public function generateBaseRow() {
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
        $this->makeDirectory($generatedBasePath);

        $baseFile = $this->projectRoot . $generatedBasePath . 'Row.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $base = Zend_CodeGenerator_Php_Class::fromReflection(
            new Zend_Reflection_Class('DDM_Scaffold_Template_Base_Row')
        );
        $base->setSourceDirty(true);
        $base->setName($baseClassName);
        $base->setExtendedClass($this->parentClass['row']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $baseBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
        $this->makeDirectory($baseBasePath);

        $classFile = $this->projectRoot . $baseBasePath . 'Row.php';
        $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
        $this->baseClass['row'] = $className;
        if (!file_exists($classFile)) {
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'This class can be used to customize '.$this->parentClass['row'].' with application specific logic. ';
            $docBlock .= 'All other row classes extend from this class.';

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Returns the row filename for a given table
     *
     * @param array $table
     *
     * @return string $fileName
     */
    protected function getRowFile($table) {
        $this->createDefaultPaths(array(
            'rows' => 'Rows/',
        ));
        $fileName = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        return $fileName;
    }

    /**
     * Returns the row class for a given table
     *
     * @param array $table
     *
     * @return string $className
     */
    protected function getRowClass($table) {
        $fileName = $this->getRowFile($table);
        $className = $this->convertFileNameToClassName($fileName, $this->paths['application'] . $this->paths['modules']);
        return $className;
    }

/*===============================
** Form Generator
**===============================*/

    /**
     * Master function to create the form class for all tables in every databases requested
     *
     * @return void
     */
    public function generateForms() {
        $this->output('==Form Generator Initiated==');
        $this->generateBaseForm();

        $this->createDefaultPaths(array(
            'forms' => 'Forms/',
        ));
        $applicationBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['forms'];
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['forms'];

        $this->makeDirectory($applicationBasePath);
        $this->makeDirectory($generatedBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($applicationBasePath . $namespace);
            $this->makeDirectory($generatedBasePath . $namespace);

            $tables = $this->getTables($database);
            foreach ($tables as $table) {
                $results = $this->generateForm($table);
                if (!$results) {
                    $this->output('Form class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
                }
            }
        }
        $this->output('==Form Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the form classes
     *
     * @param array $table
     *
     * @return boolean
     */
    protected function generateForm($table) {
        $baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['forms'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $baseProperties = array();

        $baseProperties[] = array(
            'name'         => '_tableClass',
            'visibility'   => 'protected',
            'defaultValue' => $this->getTableClass($table),
            'docblock' => 'Zend_Db_Table_Abstract class name',
        );

        $baseProperties[] = array(
            'name' => '_inputPrefix',
            'visibility' => 'protected',
            'defaultValue' => strtolower($table['namespace']) . '_' . strtolower($table['classNamePartial']),
            'docblock' => 'Value to use when prefixing the input names',
        );

        $baseMethods = array();

        $codeCreateElements = '';
        foreach ($table['COLUMNS'] as $column) {
            $label = $this->getColumnLabel($column);
            $variableName = preg_replace('/[^\w_]/', '', $column['COLUMN_NAME']);
            $element = $this->getColumnFormElement($column);
            $maxLength = $this->getColumnMaxLength($column);
            $validators = $this->getColumnValidators($column);
            $filters = $this->getColumnFilters($column);

            $inputOptions = array();
            $inputAttributes = array();

            if ($column['DATA_TYPE'] == 'enum') {
                $populateFunctionName = 'populate_' . $column['COLUMN_NAME'];
                $populateFunctionName = $this->makeClassName($populateFunctionName, false);

                $emptyOption = '';
                if ($column['IS_NULLABLE'] === 'YES') {
                    $emptyOption = "\$selectInput->addMultiOption('', '');\n\t\$selectInput->setRequired(false);";
                }

                $options = array();
                foreach ($column['VALUES'] as $value) {
                    $options[$value] = $value;
                }
                $populateEnum = array(
                    'name' => $populateFunctionName,
                    'visibility' => 'protected',
                    'parameters' => array(
                        array(
                            'name' => 'keyField',
                            'defaultValue' => null,
                        ),
                        array(
                            'name' => 'valueField',
                            'defaultValue' => null,
                        ),
                    ),
                    'body' => "
\$selectInput = \$this->getElement(\$this->convertToFormKey('{$column['COLUMN_NAME']}'));
\$options = ".$this->convertToPhpCodeString($options).";
if (count(\$options)) {
    $emptyOption
    \$selectInput->addMultiOptions(\$options);
}
",
                    'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
                        'shortDescription' => 'Populates the ' . $column['COLUMN_NAME'] . ' field',
                        'tags' => array(
                            new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                                'paramname' => 'keyField',
                            )),
                            new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                                'paramname' => 'valueField',
                            )),
                        )
                    )),
                );
                $baseMethods[] = $populateEnum;
            }

            if (count($validators)) {
                $inputOptions['validators'] = $validators;
            }
            if (count($filters)) {
                $inputOptions['filters'] = $filters;
            }
            if ($label !== false && $element != 'Zend_Form_Element_Hidden') {
                $inputOptions['label'] = $label;
            }
            if (!empty($maxLength)) {
                $inputAttributes['maxlength'] = $maxLength;
            }
            $inputOptions = $this->convertToPhpCodeString($inputOptions);

            $codeCreateElements .= "\$$variableName = new $element(\$this->convertToFormKey('{$column['COLUMN_NAME']}'),\n\t$inputOptions\n);";
            if (count($inputAttributes)) {
                foreach ($inputAttributes as $key => $value) {
                    $codeCreateElements .= "\n\$$variableName" . "->setAttrib('$key', '$value');";
                    if ($key == 'maxlength') {
                        if ($value > 1000000) {
                            $value = 1000000;
                        }
                        if (!$this->isColumnNumeric($column)) {
                            // stringLength checks type, must be a string.
                            $codeCreateElements .= "\n\$$variableName" . "->addValidator('stringLength', false, array(0, $value));";
                        }
                    }
                }
            }

            // Remove decorators if we have a hidden element
            if ($element == 'Zend_Form_Element_Hidden') {
                $codeCreateElements .= "\n\${$variableName}->setDecorators(array('ViewHelper'));";
            }

            $codeCreateElements .= "\n\$this->addElement(\$$variableName);\n\n";
        }

        $codeCreateElements .= "\$this->addElement('submit', 'Submit');\n";

        // constructor
        $const = array(
            'name' => '__construct',
            'body' => "
parent::__construct();
$codeCreateElements
\$this->populateOptions();",
            'docblock'   => new Zend_CodeGenerator_Php_Docblock(array(
                'shortDescription' => 'The constructor',
                )),
        );
        $baseMethods[] = $const;

        $baseDocBlock = $baseClassName . "\n\n";
        $baseDocBlock .= 'Generated class file for form '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
        $baseDocBlock .= 'Any changes here will be overridden.';

        $base = new Zend_CodeGenerator_Php_Class();
        $base->setName($baseClassName);
        $base->setDocblock($baseDocBlock);
        $base->setAbstract(true);
        $base->setProperties($baseProperties);
        $base->setMethods($baseMethods);
        $base->setExtendedClass($this->baseClass['form']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['forms'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
        if (!file_exists($classFile)) {
            $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'Form for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
            $docBlock .= 'This class is a descendant of '.$this->parentClass['form'].' and can be used to add customizations to ' . $baseClassName;

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

    /**
     * Creates the application specific form class. Aborts early if class already exists
     *
     * @return void
     */
    public function generateBaseForm() {
        $generatedBasePath = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
        $this->makeDirectory($generatedBasePath);

        $baseFile = $this->projectRoot . $generatedBasePath . 'Form.php';
        $baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
        $this->output($baseClassName . '... ', false);

        $base = Zend_CodeGenerator_Php_Class::fromReflection(
            new Zend_Reflection_Class('DDM_Scaffold_Template_Base_Form')
        );
        $base->setSourceDirty(true);
        $base->setName($baseClassName);
        $base->setExtendedClass($this->parentClass['form']);
        $baseCode = $base->generate();

        $this->writeFile($baseFile, $baseCode);
        $this->output('done');

        $baseBasePath = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
        $this->makeDirectory($baseBasePath);

        $classFile = $this->projectRoot . $baseBasePath . 'Form.php';
        $className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
        $this->baseClass['form'] = $className;
        if (!file_exists($classFile)) {
            $this->output($className . '... ', false);

            $docBlock = $className . "\n\n";
            $docBlock .= 'This class can be used to customize '.$this->parentClass['form'].' with application specific logic. ';
            $docBlock .= 'All other form classes extend from this class.';

            $class = new Zend_CodeGenerator_Php_Class();
            $class->setName($className);
            $class->setDocblock($docBlock);
            $class->setExtendedClass($baseClassName);
            $classCode = $class->generate();

            $this->writeFile($classFile, $classCode);
            $this->output('done');
        }

        return true;
    }

/*===============================
** Constants Generator
**===============================*/

    /**
     * Master function to create the constant classes based off of constants.cfg
     *
     * @return void
     */
    public function generateConstants() {
        $this->output('==Constants Generator Initiated==');
        /* Make sure we have a constants.cfg file where expected */
        if (!file_exists(APPLICATION_PATH . '/configs/constants.cfg')) { return false; }
        include(APPLICATION_PATH . '/configs/constants.cfg');

        /* Make sure the included file created the constants variable and it's an array */
        if (!isset($constants) || !is_array($constants)) { return false; }

        $this->createDefaultPaths(array(
            'constants' => 'Constants/',
        ));
        $constantsBaseDir = $this->paths['library'] . $this->paths['generated'] . $this->paths['constants'];
        $this->makeDirectory($constantsBaseDir);

        /* Loop through all databases in the constants array */
        foreach ($constants as $schema => $tables) {
            if (!is_array($tables)) { continue; }

            $namespace = $this->makeNamespace($schema);
            $this->makeDirectory($constantsBaseDir . $namespace);

            foreach ($tables as $table => $options) {
                if (!is_array($options)) { continue; }

                $table = array(
                    'TABLE_SCHEMA' => $schema,
                    'TABLE_NAME' => $table,
                    'namespace' => $namespace,
                );

                $result = $this->generateConstant($table, $options);
                if (!$result) {
                    $this->output('Unable to generate constants for ' . $tableName);
                }
            }
        }
        $this->output('==Constants Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the constant classes
     *
     * @param array $table
     * @param array $options
     *
     * @return boolean
     */
    protected function generateConstant($table, $options) {
        if (!array_key_exists('key', $options) || !array_key_exists('value', $options)) { return false; }

        $classNamePartial = $this->makeClassName($table['TABLE_NAME']);
        $classFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['constants'] . $table['namespace'] . '/'. $classNamePartial . '.php';
        $className = $this->convertFileNameToClassName($classFile, $this->paths['library']);
        $this->output($className . '... ', false);

        $sql = 'SELECT `' . $options['key'] . '`, `' . $options['value'] . '`'
            . 'FROM `' . $table['TABLE_SCHEMA'] . '`.`' . $table['TABLE_NAME'] . '`';
        $rows = $this->db->fetchAll($sql);

        $properties = array();
        foreach ($rows as $index => $row) {
            $name = preg_replace('/[^A-z0-9]/i', '_', $row[$options['key']]);
            if (array_key_exists('prefix', $options)) {
                $name = preg_replace('/[^A-z0-9]/i', '_', $options['prefix']) . '_' . $name;
            }
            $name = strtoupper($name);

            $properties[] = array(
                'name' => $name,
                'defaultValue' => $row[$options['value']],
                'const' => true,
            );
        }

        $methods = array();


        @$docBlock = "$className\n\nGenerated class constants file for table ". $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\nAny changes here will be overridden.\n";

        $class = new Zend_CodeGenerator_Php_Class();
        $class->setName($className);
        $class->setDocblock($docBlock);
        $class->setProperties($properties);
        $class->setMethods($methods);
        $classCode = $class->generate();

        $this->writeFile($classFile, $classCode);
        $this->output('done');

        return true;
    }

/*===============================
** SQL Generator
**===============================*/

    /**
     * Master function to create the sql dump for every databases requested
     *
     * @return void
     */
    protected function generateSQLDumps() {
        $this->output('==SQL Dumps Generator Initiated==');

        $this->createDefaultPaths(array(
            'mysql' => 'mysql/',
            'mysql_dumps' => 'dumps/',
        ));
        $mysqlBasePath = $this->paths['mysql'];

        $this->makeDirectory($mysqlBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($mysqlBasePath . $namespace);
            $this->makeDirectory($mysqlBasePath . $namespace . '/' . $this->paths['mysql_dumps']);

            $results = $this->generateSQLDump($database, $namespace);
            if (!$results) {
                $this->output('Mysql Dump could not be created for ' . $database);
            }
        }
        $this->output('==SQL Dumps Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the sql dump for each database
     *
     * @param string $database
     * @param string $namespace
     *
     * @return boolean
     */
    protected function generateSQLDump($database, $namespace) {
        $this->output($database . '... ', false);
        $fileName = $this->projectRoot . $this->paths['mysql'] . $namespace . '/' . $this->paths['mysql_dumps'] . '_current.sql';

        $databaseParams = $this->config['resources']['db']['params'];

        $host = '-h ' . $databaseParams['host'];
        $username = '-u ' . $databaseParams['username'];
        $password = '-p' . $databaseParams['password'];

        // Requires that mysqldump is accessible in the web user's PATH
        $result = shell_exec("mysqldump $host $username $password --no-data $database");
        $sql = preg_replace('/ AUTO_INCREMENT=\d+/', '', $result);
        $this->writeFile($fileName, $sql, 'sql');
        $this->output('done');
        return true;
    }

    /**
     * Master function to create the sql for all tables in every databases requested
     *
     * @return void
     */
    protected function generateTablesSQL() {
        $this->output('==Table SQL Generator Initiated==');

        $this->createDefaultPaths(array(
            'mysql' => 'mysql/',
            'mysql_tables' => 'tables/',
        ));
        $mysqlBasePath = $this->paths['mysql'];

        $this->makeDirectory($mysqlBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($mysqlBasePath . $namespace);
            $this->makeDirectory($mysqlBasePath . $namespace . '/' . $this->paths['mysql_tables']);

            $tables = $this->getTables($database);
            foreach ($tables as $table) {
                $results = $this->generateTableSQL($table);
                if (!$results) {
                    $this->output('Table sql could not be created for ' . $database . '.' . $table['TABLE_NAME']);
                }
            }
        }
        $this->output('==Table SQL Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the sql for each table
     *
     * @param array $table
     *
     * @return boolean
     */
    protected function generateTableSQL($table) {
        $this->output($table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . '... ', false);
        $showTable = $this->db->query('SHOW CREATE TABLE ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'])->fetch();
        $fileName = $this->projectRoot . $this->paths['mysql'] . $table['namespace'] . '/' . $this->paths['mysql_tables'] . $table['classNamePartial'] . '.sql';
        $sql = preg_replace('/ AUTO_INCREMENT=\d+/', '', $showTable['Create Table']);
        $this->writeFile($fileName, $sql, 'sql');
        $this->output('done');
        return true;
    }

    /**
     * Master function to create the sql for all triggers in every databases requested
     *
     * @return void
     */
    protected function generateTriggersSQL() {
        $this->output('==Trigger SQL Generator Initiated==');

        $this->createDefaultPaths(array(
            'mysql' => 'mysql/',
            'mysql_triggers' => 'triggers/',
        ));
        $mysqlBasePath = $this->paths['mysql'];

        $this->makeDirectory($mysqlBasePath);

        foreach ($this->databases as $database) {
            $namespace = $this->makeNamespace($database);
            $this->makeDirectory($mysqlBasePath . $namespace);
            $this->makeDirectory($mysqlBasePath . $namespace . '/' . $this->paths['mysql_triggers']);

            $triggers = $this->getTriggers($database);
            foreach ($triggers as $trigger) {
                $results = $this->generateTriggerSQL($trigger);
                if (!$results) {
                    $this->output('Trigger sql could not be created for ' . $database . '.' . $trigger['Trigger']);
                }
            }
        }
        $this->output('==Trigger SQL Generator Complete==');
    }

    /**
     * Delegate function that does the actual work of creating the sql for each trigger
     *
     * @param array $trigger
     *
     * @return boolean
     */
    protected function generateTriggerSQL($trigger) {
        $this->output($trigger['TRIGGER_SCHEMA'] . '.' . $trigger['TRIGGER_NAME'] . '... ', false);
        $fileName = $this->projectRoot . $this->paths['mysql'] . $trigger['namespace'] . '/' . $this->paths['mysql_triggers'] . $trigger['classNamePartial'] . '.sql';

        $sql = 'DELIMITER ;;' . "\n";
        $sql .= 'DROP TRIGGER IF EXISTS ' . $trigger['TRIGGER_NAME'] . ";\n";
        $sql .= 'CREATE TRIGGER ' . $trigger['TRIGGER_NAME'] . "\n";
        $sql .= $trigger['ACTION_TIMING'] . ' ' . $trigger['EVENT_MANIPULATION'] . ' ON ' . $trigger['EVENT_OBJECT_TABLE'] . "\n";
        $sql .= 'FOR EACH ROW' . "\n";
        $sql .= $trigger['ACTION_STATEMENT'] . ";;\n\n";
        $sql .= 'DELIMITER ;';

        $this->writeFile($fileName, $sql, 'sql');
        $this->output('done');
        return true;
    }
}
