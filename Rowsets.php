<?php

/**
 * Scaffold will generate a base and a child class that extends from the base.
 * The base class will be overwritten every single time. Do NOT add any code to the base as it will be overwritten.
 * The child class acts as a shell and should be used to extend and add functionality to the base case
 *
 * The following files types are generated by Scaffold:
 *
 * Table
 * Rowset
 * Row
 * Form
 * Constants
 *
 * http://zendframework.com/manual/en/zend.codegenerator.html
 *
 */
class DDM_Scaffold_Rowsets extends DDM_Scaffold_Abstract {

/*===============================
** Properties
**===============================*/	

	protected $parent_class = array();
	protected $base_class = array();
	
/*=================================
** Constructor and Related Methods
**=================================*/
	
	/**
	 * Allows setting up of parent classes that should be used
	 *
	 * @param array $config
	 * @return void
	 */
	protected function initGeneral($config) {
		if(!array_key_exists('parent_class', $config)) {
			$config['parent_class'] = array();
		}
		
		if(!array_key_exists('table', $config['parent_class'])) {
			$config['parent_class']['table'] = 'Zend_Db_Table_Abstract';
		}
		
		if(!array_key_exists('rowset', $config['parent_class'])) {
			$config['parent_class']['rowset'] = 'Zend_Db_Table_Rowset_Abstract';
		}
		
		if(!array_key_exists('row', $config['parent_class'])) {
			$config['parent_class']['row'] = 'Zend_Db_Table_Row_Abstract';
		}
		
		if(!array_key_exists('form', $config['parent_class'])) {
			$config['parent_class']['form'] = 'ZendX_JQuery_Form';
		}
		
		$this->parent_class = $config['parent_class'];
	}
	
/*===============================
** Main Generator
**===============================*/
	
	/**
	 * Generate acts as a helper method to call all other generate methods
	 *
	 * @return void
	 */
	public function generate() {
		$this->output('===Master Generator Initiated===');
		$this->generateTables();
		$this->generateRowsets();
		$this->generateRows();
		$this->generateForms();
		$this->generateConstants();
		$this->output('===Master Generator Complete===');
	}
	
/*===============================
** Table Generator
**===============================*/

	/**
	 * Master function to create the table class for all tables in every databases requested
	 *
	 * @return void
	 */
	public function generateTables() {
		$this->output('==Table Generator Initiated==');
		$this->generateBaseTable();
		
		$this->createDefaultPaths(array(
			'tables' => 'Tables/',
		));
		$application_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['tables'];
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['tables'];
		
		$this->makeDirectory($application_base_path);
		$this->makeDirectory($generated_base_path);
		
		foreach($this->databases as $database) {
			$ns = $this->makeNamespace($database);
			$this->makeDirectory($application_base_path . $ns);
			$this->makeDirectory($generated_base_path . $ns);
			
			$tables = $this->getTables($database);
			foreach($tables as $table) {
				$results = $this->generateTable($table);
				if(!$results) {
					$this->output('Table class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
				}
			}
		}
		$this->output('==Table Generator Complete==');
	}
	
	/**
	 * Delegate function that does the actual work of creating the table classes
	 *
	 * @param string $table
	 * @return boolean
	 */
	protected function generateTable($table) {
		$baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['tables'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		/* =================== */
		/* = Base Properties = */
		/* =================== */

        // Columns
        $columns = array();
        $has_auto_increment = false;
    	// We create a variable to pull defaults for a row class instead of information coming from the DB so we can customize the results using mysql column comments, etc
    	$defaultValues = array();
        foreach($table['COLUMNS'] as $column){
            $columns[] = $column['COLUMN_NAME'];
            if(strpos($column['EXTRA'], 'auto_increment') !== false) {
            	$has_auto_increment = true;
            }
    		$defaultValues[$column['COLUMN_NAME']] = $this->getDefaultColumnValue($column);
        }
        
        // Use the foreign key constraints to build up reference maps between the tables
        $reference_map = array();
        foreach($table['KEYS'] as $key) {
        	$refTableFile = $this->paths['tables'] . $table['namespace'] . '/' . $this->makeClassName($key['REFERENCED_TABLE_NAME']);
        	$refTableClass = $this->convertFileNameToClassName($refTableFile);
        	$map = array(
        		'columns' => $key['COLUMN_NAME'],
        		'refTableClass' => $refTableClass,
        		'refColumns' => $key['REFERENCED_COLUMN_NAME'],
        	);
        	$reference_map[$key['CONSTRAINT_NAME']] = $map;
        }
		
		$baseProperties = array();
		$baseProperties[] = array(
        	'name'         => '_metadata',
        	'visibility'   => 'protected',
        	'defaultValue' => $table['zend_describe_table'],
        	'docblock' => 'Meta data cache to avoid describes at run time'
    	);

        $baseProperties[] = array(
        	'name'         => '_schema',
        	'visibility'   => 'protected',
        	'defaultValue' => $table['TABLE_SCHEMA'],
        	'docblock' => 'DB name'
    	);

        $baseProperties[] = array(
        	'name'         => '_name',
        	'visibility'   => 'protected',
        	'defaultValue' => $table['TABLE_NAME'],
        	'docblock' => 'Table name'
    	);

        $baseProperties[] = array(
        	'name'         => '_sequence',
        	'visibility'   => 'protected',
        	'defaultValue' => $has_auto_increment,
        	'docblock' => 'Does this table have an Auto Increment field?'
    	);
    	
        $baseProperties[] = array(
            'name'         => '_cols',
            'visibility'   => 'protected',
            'defaultValue' => $columns,
            'docblock' => 'Columns in the table'
        );

        $baseProperties[] = array(
        	'name'         => '_primary',
        	'visibility'   => 'protected',
        	'defaultValue' => $table['PRIMARY_COLUMNS'],
        	'docblock' => 'Fields that make up the Primary Key'
    	);
    	
    	$baseProperties[] = array(
    		'name' => '_referenceMap',
    		'visibility' => 'protected',
    		'defaultValue' => $reference_map,
    		'docblock' => 'Reference mapping from this table to other tables',
    	);
    	
    	$baseProperties[] = array(
    		'name' => '_defaultValues',
    		'visibility' => 'protected',
    		'defaultValue' => $defaultValues,
    		'docblock' => 'Default values for a new row class',
    	);
    	
    	$baseProperties[] = array(
    		'name' => '_rowsetClass',
    		'visibility' => 'protected',
    		'defaultValue' => $this->getRowsetClass($table),
    		'docblock' => 'Rowset class to use with table',
    	);
    	
    	$baseProperties[] = array(
    		'name' => '_rowClass',
    		'visibility' => 'protected',
    		'defaultValue' => $this->getRowClass($table),
    		'docblock' => 'Row class to use with table',
    	);
		
		/* ================ */
		/* = Base Methods = */
		/* ================ */
		
		$baseMethods = array();
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated class file for table '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->base_class['table']);
		$baseCode = $base->generate();

		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['tables'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		if(!file_exists($classFile)) {
			$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'Table for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
			$docBlock .= 'This class is a descendant of '.$this->parent_class['table'].' and can be used to add customizations to ' . $baseClassName;
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}
	
	/**
	 * Creates the application specific table class. Aborts early if class already exists
	 *
	 * @return void
	 */
	public function generateBaseTable() {
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
		$this->makeDirectory($generated_base_path);
		
		$baseFile = $this->projectRoot . $generated_base_path . 'Table.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		/* =================== */
		/* = Base Properties = */
		/* =================== */
		
		$baseProperties = array();
        
        $baseProperties[] = array(
            'name'         => '_metadataCacheInClass',
            'visibility'   => 'protected',
            'defaultValue' => true,
            'docblock'     => 'The table metadata has been cached'
        );
    	
    	$baseProperties[] = array(
    		'name' => '_defaultSource',
    		'visibility' => 'protected',
    		'defaultValue' => new Zend_CodeGenerator_Php_Property_DefaultValue(array(
    			'type' => 'constant',
    			'value' => 'self::DEFAULT_CLASS', 
    		)),
    		'docblock' => 'Where should the default values come for new empty rows?',
    	);
		
		/* ================ */
		/* = Base Methods = */
		/* ================ */
		
		$baseMethods = array();

		$getSchema = array(
			'name' => 'getSchema',
			'body' => 'return $this->_schema;',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
            	'shortDescription' => 'Returns the schema of the table',
                'tags' => array(
                    new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                        'paramName' => 'return',
                        'datatype'  => 'string'
                    )),
                ),
			)),
		);
		$baseMethods[] = $getSchema;

		$getTableName = array(
			'name' => 'getTableName',
			'body' => 'return $this->_name;',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
            	'shortDescription' => 'Returns the name of the table',
                'tags' => array(
                    new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                        'paramName' => 'return',
                        'datatype'  => 'string'
                    )),
                ),
			)),
		);
		$baseMethods[] = $getTableName;

		$getPrimaryKeys = array(
			'name' => 'getPrimaryKeys',
			'body' => 'return $this->_primary;',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
            	'shortDescription' => 'Get an array of primary keys',
                'tags' => array(
                    new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                        'paramName' => 'return',
                        'datatype'  => 'array'
                    )),
                ),
			)),
		);
		$baseMethods[] = $getPrimaryKeys;
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated base class file for tables' . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->parent_class['table']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$base_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
		$this->makeDirectory($base_base_path);
		
		$classFile = $this->projectRoot . $base_base_path . 'Table.php';
		$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
		$this->base_class['table'] = $className;
		if(!file_exists($classFile)) {
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'This class can be used to customize '.$this->parent_class['table'].' with application specific logic. ';
			$docBlock .= 'All other table classes extend from this class.';
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}
	
/*===============================
** Rowset Generator
**===============================*/

	/**
	 * Master function to create the rowset class for all tables in every databases requested
	 *
	 * @return void
	 */
	public function generateRowsets() {
		$this->output('==Rowset Generator Initiated==');
		$this->generateBaseRowset();
		
		$this->createDefaultPaths(array(
			'rowsets' => 'Rowsets/',
		));
		$application_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'];
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['rowsets'];
		
		$this->makeDirectory($application_base_path);
		$this->makeDirectory($generated_base_path);
		
		foreach($this->databases as $database) {
			$ns = $this->makeNamespace($database);
			$this->makeDirectory($application_base_path . $ns);
			$this->makeDirectory($generated_base_path . $ns);
			
			$tables = $this->getTables($database);
			foreach($tables as $table) {
				$results = $this->generateRowset($table);
				if(!$results) {
					$this->output('Rowset class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
				}
			}
		}
		$this->output('==Rowset Generator Complete==');
	}
	
	/**
	 * Delegate function that does the actual work of creating the rowset classes
	 *
	 * @param string $table
	 * @return boolean
	 */
	protected function generateRowset($table) {
		$baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		$baseProperties = array();
		$baseMethods = array();
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated class file for rowset '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->base_class['rowset']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		if(!file_exists($classFile)) {
			$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'Rowset for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
			$docBlock .= 'This class is a descendant of '.$this->parent_class['rowset'].' and can be used to add customizations to ' . $baseClassName;
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}
	
	/**
	 * Creates the application specific rowset class. Aborts early if class already exists
	 *
	 * @return void
	 */
	public function generateBaseRowset() {
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
		$this->makeDirectory($generated_base_path);
		
		$baseFile = $this->projectRoot . $generated_base_path . 'Rowset.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		$baseProperties = array();
		$baseMethods = array();
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated base class file for rowsets' . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->parent_class['rowset']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$base_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
		$this->makeDirectory($base_base_path);
		
		$classFile = $this->projectRoot . $base_base_path . 'Rowset.php';
		$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
		$this->base_class['rowset'] = $className;
		if(!file_exists($classFile)) {
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'This class can be used to customize '.$this->parent_class['rowset'].' with application specific logic. ';
			$docBlock .= 'All other rowset classes extend from this class.';
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}

	/**
	 * Returns the rowset filename for a given table
	 *
	 * @param array $table
	 * @return string $fileName
	 */
	protected function getRowsetFile($table) {
		$this->createDefaultPaths(array(
			'rowsets' => 'Rowsets/',
		));
		$fileName = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rowsets'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		return $fileName;
	}

	/**
	 * Returns the rowset class for a given table
	 *
	 * @param array $table
	 * @return string $className
	 */
	protected function getRowsetClass($table) {
		$fileName = $this->getRowsetFile($table);
		$className = $this->convertFileNameToClassName($fileName, $this->paths['application'] . $this->paths['modules']);
		return $className;
	}
	
/*===============================
** Row Generator
**===============================*/

	/**
	 * Master function to create the row class for all tables in every databases requested
	 *
	 * @return void
	 */
	public function generateRows() {
		$this->output('==Row Generator Initiated==');
		$this->generateBaseRow();
		
		$this->createDefaultPaths(array(
			'rows' => 'Rows/',
		));
		$application_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'];
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['rows'];
		
		$this->makeDirectory($application_base_path);
		$this->makeDirectory($generated_base_path);
		
		foreach($this->databases as $database) {
			$ns = $this->makeNamespace($database);
			$this->makeDirectory($application_base_path . $ns);
			$this->makeDirectory($generated_base_path . $ns);
			
			$tables = $this->getTables($database);
			foreach($tables as $table) {
				$results = $this->generateRow($table);
				if(!$results) {
					$this->output('Row class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
				}
			}
		}
		$this->output('==Row Generator Complete==');
	}
	
	/**
	 * Delegate function that does the actual work of creating the row classes
	 *
	 * @param string $table
	 * @return boolean
	 */
	protected function generateRow($table) {
		$baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		$baseProperties = array();
		
		/* ================ */
		/* = Base Methods = */
		/* ================ */
		
		$baseMethods = array();
		
		// Create the getter/setters for each column
		foreach($table['COLUMNS'] as $column) {
			$functionName = $this->makeClassName($column['COLUMN_NAME']);
			$columnType = $this->getColumnVarType($column);
			
			// Getter Variables
			$returnType = $columnType;
			$getParameters = array();
			$getDocblock = array(
				'shortDescription' => 'Returns the value for ' . $column['COLUMN_NAME'],
				'tags' => array(),
			);
			
			// Setter Variables
			$paramType = $columnType;
			$autocast = true;
			$setParameters = array(array(
				'name' => 'value'
			));
			$setDocblock = array(
				'shortDescription' => 'Sets the value for ' . $column['COLUMN_NAME'],
				'tags' => array(),
			);
			
			$getBody = '$value = $this->getColumnValue(\''.$column['COLUMN_NAME'].'\');'."\n";
			$setBody = '';
			
			// If the column is time related, we need to store it in the correct format for saving to the database
			if($this->isColumnTimeRelated($column)) {
				$dateFormat = $this->getDateFormatForColumn($column);
				
				$returnType .= '|int';
				// Give an option to return a timestamp if desired instead of the date string
				$getParameters[] = array(
					'name' => 'return_unixtime',
					'defaultValue' => false,
				);
				$getDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
					'datatype' => 'boolean',
					'paramName' => 'return_unixtime',
					'description' => 'OPTIONAL',
					'position' => 1,
				));
				$getBody .= 'if('.(($column['IS_NULLABLE'] == 'YES') ? '$value !== null && ' : '').'$return_unixtime) {
	$value = strtotime($value);
}
';

				// Give an option to not convert a string and reapply the date format. This allows people to pass in already
				// formated dates that occur before either 1901 or 1970 depending on the system
				$paramType .= '|int';
				$setParameters[] = array(
					'name' => 'convert_string',
					'defaultValue' => true,
				);
				$setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
					'paramName' => 'convert_string',
					'datatype' => 'boolean',
					'description' => 'OPTIONAL',
				));
				
				$setBody .= '
if($value == \'CURRENT_TIMESTAMP\') {
	$value = date(\''.$dateFormat.'\');
} else if(is_numeric($value)) {
	$value = date(\''.$dateFormat.'\', $value);
} else if('.(($column['IS_NULLABLE'] == 'YES') ? '$value !== null && ' : '').'$convert_string) {
	$value = date(\''.$dateFormat.'\', strtotime($value));
}
';	
			} else if(strpos($column['COLUMN_COMMENT'], 'SERIALIZED_DATA') !== false) {
				// No special logic is needed for nulls here as serialize handles it correctly
				$autocast = false;
				$getBody .= '$value = unserialize($value);'."\n";
				$setBody .= '$value = serialize($value);'."\n";
			} else if(strpos($column['COLUMN_COMMENT'], 'BOOLEAN') !== false) {
				$autocast = false;
				if($column['IS_NULLABLE'] == 'YES') {
					$getBody .= 'if($value !== null) {'."\n";
				}
				$getBody .= '$value = (boolean) $value;'."\n";
				if($column['IS_NULLABLE'] == 'YES') {
					$getBody .= 'if($value !== null) {'."\n";
				}
				
				// If we cast to a boolean and then an int, PHP leans toward true too often.
				if($column['IS_NULLABLE'] == 'YES') {
					$setBody .= 'if($value !== null) {'."\n";
				}
				$setBody .= '
if($value === true || $value == 1 || $value === \'true\' || $value === \'TRUE\') {
	$value = 1;
} else {
	$value = 0;
}	
';
				if($column['IS_NULLABLE'] == 'YES') {
					$setBody .= '}'."\n";
				}
			} else if(strpos($column['COLUMN_COMMENT'], 'IP_ADDRESS') !== false) {
				$paramType = 'string';
				$returnType = 'string';
				$autocast = false;
				
				if($column['IS_NULLABLE'] == 'YES') {
					$getBody .= 'if($value !== null) {'."\n";
				}
					$getBody .= '$value = long2ip($value);'."\n";
				if($column['IS_NULLABLE'] == 'YES') {
					$getBody .= '}'."\n";
				}
				
				if($column['IS_NULLABLE'] == 'YES') {
					$setBody .= 'if($value !== null) {'."\n";
				}
					$setBody .= '$value = sprintf(\'%u\', ip2long($value));'."\n";
				if($column['IS_NULLABLE'] == 'YES') {
					$setBody .= '}'."\n";
				}
			}
			
			// Cast the value to the correct type
			if($autocast) {
				if($column['IS_NULLABLE'] == 'YES') {
					$setBody .= '
if($value !== null) {
	$value = ('.$columnType.') $value;
}'."\n";
				} else {
					$setBody .= '$value = ('.$columnType.') $value;'."\n";
				}
			}
			
			// Finish up the getter
			$getBody .= 'return $value;';
			$getDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
				'datatype' => $returnType,
			));
			$baseMethods[] = array(
				'name' => 'get' . $functionName,
				'visibility' => 'public',
				'parameters' => $getParameters,
				'body' => $getBody,
				'docblock' => $getDocblock,
			);
			
			
			// Finish up the setter
			$setBody .= '$this->setColumnValue(\''.$column['COLUMN_NAME'].'\', $value);';
			$setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
				'paramName' => 'value',
				'datatype' => $paramType,
			));
			$setDocblock['tags'][] = new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
				'datatype' => 'void',
			));
			$baseMethods[] = array(
				'name' => 'set' . $functionName,
				'visibility' => 'public',
				'parameters' => $setParameters,
				'body' => $setBody,
				'docblock' => $setDocblock,
			);
		}
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated class file for row '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->base_class['row']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		if(!file_exists($classFile)) {
			$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'Row for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
			$docBlock .= 'This class is a descendant of '.$this->parent_class['row'].' and can be used to add customizations to ' . $baseClassName;
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}
	
	/**
	 * Creates the application specific row class. Aborts early if class already exists
	 *
	 * @return void
	 */
	public function generateBaseRow() {
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
		$this->makeDirectory($generated_base_path);
		
		$baseFile = $this->projectRoot . $generated_base_path . 'Row.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		/* =================== */
		/* = Base Properties = */
		/* =================== */
		
		$baseProperties = array();
		
		$baseProperties[] = array(
			'name' => '_functionNameFilter',
			'visibility' => 'protected',
			'defaultValue' => null,
			'docblock' => 'The filter used to convert strings to function names',
		);
		
		$baseProperties[] = array(
			'name' => '_columnNameFilter',
			'visibility' => 'protected',
			'defaultValue' => null,
			'docblock' => 'The filter used to convert function names to strings',
		);
		
		/* ================ */
		/* = Base Methods = */
		/* ================ */
		
		$baseMethods = array();
		
		// The construct needs to be rewritten to set $_data with setFromArray() to ensure any custom setter logic is called for each column
		$__construct = array(
			'name' => '__construct',
			'visibility' => 'public',
			'parameters' => array(
				array(
					'name' => 'config',
					'type' => 'array',
					'defaultValue' => array(),	
				),
			),
			'body' => '
if (isset($config[\'table\']) && $config[\'table\'] instanceof Zend_Db_Table_Abstract) {
    $this->_table = $config[\'table\'];
    $this->_tableClass = get_class($this->_table);
} elseif ($this->_tableClass !== null) {
    $this->_table = $this->_getTableFromString($this->_tableClass);
}

if (isset($config[\'data\'])) {
    if (!is_array($config[\'data\'])) {
        throw new Zend_Db_Table_Row_Exception(\'Data must be an array\');
    }
    // We have to set the $_data column keys first because setFromArray is going to verify that the array keys exist before allowing a column to be saved
    $column_keys = array_combine(array_keys($config[\'data\']), array_fill(0, count($config[\'data\']), null));
    $this->_data = $column_keys;
    $this->setFromArray($config[\'data\']);
}
if (isset($config[\'stored\']) && $config[\'stored\'] === true) {
    $this->_cleanData = $this->_data;
}

if (isset($config[\'readOnly\']) && $config[\'readOnly\'] === true) {
    $this->setReadOnly(true);
}

// Retrieve primary keys from table schema
if (($table = $this->_getTable())) {
    $info = $table->info();
    $this->_primary = (array) $info[\'primary\'];
}

$this->init();
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Constructor overwritten to use setter methods',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'config',
						'datatype' => 'array',
						'description' => 'OPTIONAL Array of user-specified config options.',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'void',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag(array(
						'name' => 'throws',
						'description' => 'Zend_Db_Table_Row_Exception',
					)),
				)
			)),
		);
		$baseMethods[] = $__construct;
		
		// __call needs to be updated so that requests for getColumnName or setColumnName are properly routed
		$__call = array(
			'name' => '__call',
			'visibility' => 'public',
			'parameters' => array(
				array(
					'name' => 'method',
				),
				array(
					'name' => 'args',
					'type' => 'array',
				),
			),
			'body' => '
$columnName = $this->getColumnName($method);

if(strpos($columnName, \'get_\') === 0) {
	$columnName = str_replace(\'get_\', \'\', $columnName);
	return $this->getColumnValue($columnName);
} else if(strpos($columnName, \'set_\') === 0) {
	$columnName = str_replace(\'set_\', \'\', $columnName);
	return $this->setColumnValue($columnName, $args[0]);
}
			
return parent::__call($method, $args);
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Turns get and set method calls to __get and __set calls',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'method',
						'type' => 'string',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'args',
						'type' => 'array',
						'description' => 'OPTIONAL Zend_Db_Table_Select query modifier',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'Zend_Db_Table_Row_Abstract|Zend_Db_Table_Rowset_Abstract',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag(array(
						'name' => 'throws',
						'description' => 'Zend_Db_Table_Row_Exception If an invalid method is called.',
					)),
				)
			)),
		);
		$baseMethods[] = $__call;
		
		// __get needs to be overwritten so the logic in the custom getters are applied instead of accesing the value directly
		$__get = array(
			'name' => '__get',
			'visibility' => 'public',
			'parameters' => array(
				array(
					'name' => 'columnName',
				),
			),
			'body' => '
$functionName = $this->getFunctionName(\'get_\' . $columnName);			
return $this->$functionName();
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Redirects __get to a getColumnName method',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'columnName',
						'type' => 'string',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'mixed',
					)),
				)
			)),
		);
		$baseMethods[] = $__get;
		
		// __set needs to be overwritten so the logic in the custom setters are applied instead of changing the value directly
		$__set = array(
			'name' => '__set',
			'visibility' => 'public',
			'parameters' => array(
				array(
					'name' => 'columnName',
				),
				array(
					'name' => 'value',
				),
			),
			'body' => '
$functionName = $this->getFunctionName(\'set_\' . $columnName);			
return $this->$functionName($value);
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Redirects __set to a getColumnName method',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'columnName',
						'type' => 'string',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'value',
						'type' => 'mixed',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'void',
					)),
				)
			)),
		);
		$baseMethods[] = $__set;
		
		// getColumnValue does the same work that __get used to do	
		$getColumnValue = array(
			'name' => 'getColumnValue',
			'visibility' => 'protected',
			'parameters' => array(
				array(
					'name' => 'columnName',
				),
			),
			'body' => 'return parent::__get($columnName);',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Retrieve row field value',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'columnName',
						'datatype' => 'string',
						'description' => 'The user-specified column name.',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'string',
						'description' => 'The corresponding column value.',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag(array(
						'name' => 'throws',
						'description' => 'Zend_Db_Table_Row_Exception if the $columnName is not a column in the row.',
					)),
				)
			))
		);
		$baseMethods[] = $getColumnValue;
		
		// getColumnValue does the same work that __set used to do	
		$setColumnValue = array(
			'name' => 'setColumnValue',
			'visibility' => 'protected',
			'parameters' => array(
				array(
					'name' => 'columnName',
				),
				array(
					'name' => 'value',
				),
			),
			'body' => 'return parent::__set($columnName, $value);',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Set row field value',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'columnName',
						'datatype' => 'string',
						'description' => 'The column key.',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'value',
						'datatype' => 'mixed',
						'description' => 'The value for the property.',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'void',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag(array(
						'name' => 'throws',
						'description' => 'Zend_Db_Table_Row_Exception',
					)),
				)
			))
		);
		$baseMethods[] = $setColumnValue;
		
		// toArray changes to pull the data from the custom getters instead of pulling the data directly
		$toArray = array(
			'name' => 'toArray',
			'body' => '
$data = array();

foreach($this->_data as $columnName => $value) {
	$functionName = $this->getFunctionName(\'get_\' . $columnName);
	$data[$columnName] = $this->$functionName();
}

return $data;			
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Returns the column/value data as an array.',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'array',
					))
				),
			)),
		);
		$baseMethods[] = $toArray;
		
		// setFromArray changes to use the custom setters instead of editing the data directly
		$setFromArray = array(
			'name' => 'setFromArray',
			'parameters' => array(
				array(
					'name' => 'data',
					'type' => 'array',
				),
			),
			'body' => '
$data = array_intersect_key($data, $this->_data);	

foreach($data as $columnName => $value) {
	$functionName = $this->getFunctionName(\'set_\' . $columnName);
	$this->$functionName($value);
}

return $this;
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
            	'shortDescription' => 'Sets all data in the row from an array. Overwrites base so that we call setColumnName instead of __set',
                'tags' => array(
                    new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
                        'paramName' => 'data',
                        'datatype'  => 'array'
                    )),
                    new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
                        'datatype'  => 'Zend_Db_Table_Row_Abstract',
                        'description' => 'Provides a fluent interface',
                    )),
                ),
			)),
		);
		$baseMethods[] = $setFromArray;
		
		$getFunctionName = array(
			'name' => 'getFunctionName',
			'visibility' => 'protected',
			'parameters' => array(
				array(
					'name' => 'functionName',
				),
			),
			'body' => '
if($this->_functionNameFilter === null) {
	$this->_functionNameFilter = new Zend_Filter_Word_UnderscoreToCamelCase();
}

return lcfirst($this->_functionNameFilter->filter($functionName));
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Converts a string to the function name',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'functionName',
						'datatype' => 'string',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'string',
					)),
				)
			))
		);
		$baseMethods[] = $getFunctionName;
		
		$getColumnName = array(
			'name' => 'getColumnName',
			'visibility' => 'protected',
			'parameters' => array(
				array(
					'name' => 'columnName',
				),
			),
			'body' => '
if($this->_columnNameFilter === null) {
	$this->_columnNameFilter = new Zend_Filter_Word_CamelCaseToUnderscore();
}

return strtolower($this->_columnNameFilter->filter($columnName));
			',
			'docblock' => new Zend_CodeGenerator_Php_Docblock(array(
				'shortDescription' => 'Converts a string to a column name',
				'tags' => array(
					new Zend_CodeGenerator_Php_Docblock_Tag_Param(array(
						'paramName' => 'columnName',
						'datatype' => 'string',
					)),
					new Zend_CodeGenerator_Php_Docblock_Tag_Return(array(
						'datatype' => 'string',
					)),
				)
			))
		);
		$baseMethods[] = $getColumnName;
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated base class file for rows' . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->parent_class['row']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$base_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
		$this->makeDirectory($base_base_path);
		
		$classFile = $this->projectRoot . $base_base_path . 'Row.php';
		$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
		$this->base_class['row'] = $className;
		if(!file_exists($classFile)) {
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'This class can be used to customize '.$this->parent_class['row'].' with application specific logic. ';
			$docBlock .= 'All other row classes extend from this class.';
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}

	/**
	 * Returns the row filename for a given table
	 *
	 * @param array $table
	 * @return string $fileName
	 */
	protected function getRowFile($table) {
		$this->createDefaultPaths(array(
			'rows' => 'Rows/',
		));
		$fileName = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['rows'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		return $fileName;
	}

	/**
	 * Returns the row class for a given table
	 *
	 * @param array $table
	 * @return string $className
	 */
	protected function getRowClass($table) {
		$fileName = $this->getRowFile($table);
		$className = $this->convertFileNameToClassName($fileName, $this->paths['application'] . $this->paths['modules']);
		return $className;
	}
	
/*===============================
** Form Generator
**===============================*/

	/**
	 * Master function to create the form class for all tables in every databases requested
	 *
	 * @return void
	 */
	public function generateForms() {
		$this->output('==Form Generator Initiated==');
		$this->generateBaseForm();
		
		$this->createDefaultPaths(array(
			'forms' => 'Forms/',
		));
		$application_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['forms'];
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['forms'];
		
		$this->makeDirectory($application_base_path);
		$this->makeDirectory($generated_base_path);
		
		foreach($this->databases as $database) {
			$ns = $this->makeNamespace($database);
			$this->makeDirectory($application_base_path . $ns);
			$this->makeDirectory($generated_base_path . $ns);
			
			$tables = $this->getTables($database);
			foreach($tables as $table) {
				$results = $this->generateForm($table);
				if(!$results) {
					$this->output('Form class could not be created for ' . $database . '.' . $table['TABLE_NAME']);
				}
			}
		}
		$this->output('==Form Generator Complete==');
	}
	
	/**
	 * Delegate function that does the actual work of creating the form classes
	 *
	 * @param string $table
	 * @return boolean
	 */
	protected function generateForm($table) {
		$baseFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['forms'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		$baseProperties = array();
		$baseMethods = array();
		
		foreach($table['COLUMNS'] as $column) {
			$label = $this->getColumnLabel($column);
			$inputName = $this->getColumnInputName($table, $column);
			$variableName = preg_replace('/[^\w_]/', '', $inputName);
			$element = $this->getColumnFormElement($column);
			$maxLength = $this->getColumnMaxLength($column);
			$validators = $this->getColumnValidators($column);
			$filters = $this->getColumnFilters($column);
			
			$inputOptions = array();
			$inputAttributes = array();
			
			if(count($validators)) {
				$inputOptions['validators'] = $validators;
			}
			if(count($filters)) {
				$inputOptions['filters'] = $filters;
			}
			if($label !== false) {
				$inputOptions['label'] = $label;
			}
			if(!empty($maxLength)) {
				$inputAttributes['maxlength'] = $maxLength;
			}
			$inputOptions = $this->convertToPhpCodeString($inputOptions);

			$codeCreateElements .= "\$$variableName = new $element( '$inputName',\n\t$inputOptions\n);";
			if(count($inputAttributes)) {
				foreach($inputAttributes as $key => $value ) {
					$codeCreateElements .= "\n\$$variableName" . "->setAttrib('$key', '$value');\n";
					if($key == 'maxlength') {
						if($value > 1000000) {
							$value = 1000000;
						}
						if($this->isColumnNumeric($column)) {
							// stringLength checks type, must be a string.
							$codeCreateElements .= "\n\$$variableName" . "->addValidator('stringLength', false, array(0, $value));";
						}
					}
				}
			}

			$codeCreateElements .= "\n\$this->addElement(\$$variableName);\n\n";
		}

		$codeCreateElements .= "\$this->addElement( \n\t'submit',\n\t'Submit');\n";

		// constructor
		$const = array(
			'name' => '__construct',
			'body' => "parent::__construct();\n$codeCreateElements",
			'docblock'   => new Zend_CodeGenerator_Php_Docblock(array(
                'shortDescription' => 'The constructor',
				)),
		);
		$baseMethods[] = $const;
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated class file for form '. $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->base_class['form']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$classFile = $this->projectRoot . $this->paths['application'] . $this->paths['modules'] . $this->paths['forms'] . $table['namespace'] . '/' . $table['classNamePartial'] . '.php';
		if(!file_exists($classFile)) {
			$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'Form for ' . $table['TABLE_SCHEMA'] . '.' . $table['TABLE_NAME'] . "\n\n";
			$docBlock .= 'This class is a descendant of '.$this->parent_class['form'].' and can be used to add customizations to ' . $baseClassName;
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}
	
	/**
	 * Creates the application specific form class. Aborts early if class already exists
	 *
	 * @return void
	 */
	public function generateBaseForm() {
		$generated_base_path = $this->paths['library'] . $this->paths['generated'] . $this->paths['base'];
		$this->makeDirectory($generated_base_path);
		
		$baseFile = $this->projectRoot . $generated_base_path . 'Form.php';
		$baseClassName = $this->convertFileNameToClassName($baseFile, $this->paths['library']);
		$this->output($baseClassName . '... ', false);
		
		$baseProperties = array();
		$baseMethods = array();
    	
		$baseDocBlock = $baseClassName . "\n\n";
		$baseDocBlock .= 'Generated base class file for forms' . "\n";
		$baseDocBlock .= 'Any changes here will be overridden.';
		
		$base = new Zend_CodeGenerator_Php_Class();
		$base->setName($baseClassName);
		$base->setDocblock($baseDocBlock);
		$base->setAbstract(true);
		$base->setProperties($baseProperties);
		$base->setMethods($baseMethods);
		$base->setExtendedClass($this->parent_class['form']);
		$baseCode = $base->generate();
		
		$this->writeFile($baseFile, $baseCode);
		$this->output('done');
		
		$base_base_path = $this->paths['application'] . $this->paths['modules'] . $this->paths['base'];
		$this->makeDirectory($base_base_path);
		
		$classFile = $this->projectRoot . $base_base_path . 'Form.php';
		$className = $this->convertFileNameToClassName($classFile, $this->paths['application'] . $this->paths['modules']);
		$this->base_class['form'] = $className;
		if(!file_exists($classFile)) {
			$this->output($className . '... ', false);
			
			$docBlock = $className . "\n\n";
			$docBlock .= 'This class can be used to customize '.$this->parent_class['form'].' with application specific logic. ';
			$docBlock .= 'All other form classes extend from this class.';
			
			$class = new Zend_CodeGenerator_Php_Class();
			$class->setName($className);
			$class->setDocblock($docBlock);
			$class->setExtendedClass($baseClassName);
			$classCode = $class->generate();
	
			$this->writeFile($classFile, $classCode);
			$this->output('done');
		}
		
		return true;
	}

/*===============================
** Constants Generator
**===============================*/
	
	/**
	 * Generate Constants based off of APPLICATION_PATH/configs/constants.cfg
	 *
	 * @return array void
	 */
	public function generateConstants() {
		$this->output('==Constants Generator Initiated==');
		/* Make sure we have a constants.cfg file where expected */
		if(!file_exists(APPLICATION_PATH . '/configs/constants.cfg')) { return false; }
		include(APPLICATION_PATH . '/configs/constants.cfg');

		/* Make sure the included file created the constants variable and it's an array */
		if(!isset($constants) || !is_array($constants)) { return false; }
		
		$this->createDefaultPaths(array(
			'constants' => 'Constants/',
		));
		$constants_base_dir = $this->paths['library'] . $this->paths['generated'] . $this->paths['constants'];
		$this->makeDirectory($constants_base_dir);

		/* Loop through all databases in the constants array */
		foreach( $constants as $dbName => $tables ) {
			if(!is_array($tables)) { continue; }

			$ns = $this->makeNamespace($dbName);
			$this->makeDirectory($constants_base_dir . $ns);

			foreach($tables as $tableName => $options) {
				if(!is_array($options)) { continue; }

				$result = $this->makeConstants($dbName, $tableName, $options);
				if(!$result) {
					$this->output('Unable to generate constants for ' . $tableName);
				}
			}
		}
		$this->output('==Constants Generator Complete==');
	}
	
	/**
	 * Generate constants classes from database using information in constants.cfg
	 *
	 * @param array $tableInfo
	 * @return boolean
	 */
	protected function makeConstants( $dbName, $tableName, $options ) {
		if(!array_key_exists('key', $options) || !array_key_exists('value', $options)) { return false; }

		$ns = $this->makeNamespace($dbName);
		$classNamePartial = $this->makeClassName($tableName);
		$classFile = $this->projectRoot . $this->paths['library'] . $this->paths['generated'] . $this->paths['constants'] . $ns . '/'. $classNamePartial . '.php';
		$className = $this->convertFileNameToClassName($classFile, $this->paths['library']);
		$this->output($className . '... ', false);

		$sql = 'SELECT `' . $options['key'] . '`, `' . $options['value'] . '`'
			. 'FROM `' . $dbName . '`.`' . $tableName . '`';
		$rows = $this->db->fetchAll($sql);

		$properties = array();
		foreach($rows as $row) {
			$name = preg_replace('/[^A-z0-9 ]/i', '_', $row[$options['key']]);
			if(array_key_exists('prefix', $options)) {
				$name = preg_replace('/[^A-z0-9 ]/i', '_', $options['prefix']) . '_' . $name;
			}
			$name = strtoupper($name);

			$properties[] = array(
				'name' => $name,
				'defaultValue' => $row[$options['value']],
				'const' => true,
			);
		}

		@$docBlock = "$className\n\nGenerated class constants file for table ". $dbName . '.' . $tableName . "\nAny changes here will be overridden.\n";

		$class = new Zend_CodeGenerator_Php_Class();
		$class->setName($className);
		$class->setDocblock($docBlock);
		$class->setProperties($properties);
		$classCode = $class->generate();

		$this->writeFile($classFile, $classCode);
		$this->output('done');

		return true;
	}
	

}